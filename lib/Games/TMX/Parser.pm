
=head1 NAME

Games::TMX::Parser - parse tiled game maps from http://www.mapeditor.org

=head1 SYNOPSIS

    use Games::TMX::Parser;

    $map = Games::TMX::Parser->new(
        map_dir  => 'maps',
        map_file => 'tower_defense.tmx',
    )->map;

    # ----- the map ------------------
    $width       = $map->width; # all sizes in pixels
    $height      = $map->height;
    $tile_width  = $map->tile_width;
    $tile_height = $map->tile_height;

    $tileset     = $map->tilesets->[3];
    $tile        = $map->get_tile('some_tile_id'); # find in all tilesets
    $layer       = $map->get_layer('some_layer_name');

    # ----- a tileset of tiles --------
    $tile        = $tileset->tiles->[2];
    $image       = $tileset->image; # image file name in map_dir directory
    $width       = $tileset->width;
    $height      = $tileset->height;
    $tile_width  = $tileset->tile_width;
    $tile_height = $tileset->tile_height;
    $tile_count  = $tileset->tile_count;

    # ----- a tile from a tileset -----
    %props       = %{ $tile->properties };
    $value       = $tile->get_prop('some_tile_property_name');
    $tileset     = $tile->tileset;

    # ----- a layer on the map --------
    $cell        = $layer->get_cell($column, $row);
    $cell        = $layer->rows->[$row]->[$column]; # same as above
    @cells       = $layer->find_cells_with_property('some_tile_property_name');
    @cells       = $layer->all_cells;

    # ----- a cell in a layer ---------
    $tile        = $cell->tile;
    $layer       = $cell->layer;
    ($col, $row) = $cell->xy;
    $cell        = $cell->left;
    $cell        = $cell->right;
    $cell        = $cell->above;
    $cell        = $cell->below;
    $cell        = $cell->seek_next_cell; # follow a path of tiled cells on a layer

    # ----- objects -------------------
    $og          = $map->get_objectgroup('some_objectgroup');
    @obj_names   = $og->list_object_names;  # ('rect1', 'my_polygon2')
    $obj_rect1   = $og->get_objects_by_name('rect1')->[0];  # name is neither required
                                                            # nor required to be unique
                                                            # so it's an array
    $obj_rect1->positions_yx; # [ [0,0], [0,1], [1,1], [1,1] ]
    @objs_at_pos = $og->objects_for_position_yx(0, 1) # ( $obj_rect1 )


=head1 DESCRIPTION

From http://www.mapeditor.org:

    Tiled is a general purpose tile map editor. It's built to be easy to use,
    yet flexible enough to work with varying game engines, whether your game is
    an RPG, platformer or Breakout clone.

This package provides Perl access to the maps generated by Tiled, the general
purpose tile map editor. You could use it for drawing you perl game maps in
Tiled, or for writing Perl scripts which improve/analyze maps- extract
waypoints, decorate corners with shadows, add random trees, etc.

Drawing your maps in Tiled is more fun that writing your own map format and
then drawing ASCII art.

The TMX map format documentation describes the main entities:

    https://github.com/bjorn/tiled/wiki/TMX-Map-Format

=head1 HOW TO USE

In Tiled, draw your map and place properties as markers on special tiles you
want to read in Perl. Then in your Perl game, read the map and use:

    my @cells = $map->get_layer('layer_with_stuff')
                    ->find_cells_with_property('my_special_tile_marker');
 
To find your special cells (spawn points, enemy locations, etc.).

Draw a layer by iteating over:

    @{ $layer->rows };

Which will give you an ARRAY ref of cells, one per column. Then you can find
the tile of the cell using:

    $cell->tile;

And then access its properties, or cut the correct image from the tileset image file:

    $tile->tileset->image;


=head1 EXAMPLE

The distribution contains an example which computes creep waypoint column/row
for any map with a simple path drawn on it.

=head1 TODO

No support for base64 or compression of maps, uncheck the correct check boxes
in Tiled before you save.

Object support is very simple. All you can do right now is introspect positions of
objects.

Fill algorithm for polygon objects breaks for complex polygons

Objects can be larger than the map (which isn't agains the law, but an optional
warning might be useful)

=head1 DEVELOPMENT

Send pull requests to:

    https://github.com/eilara/Games-TMX-Parser

=head1 AUTHOR

Ran Eilam <eilara@cpan.org>
Konstantin Baierer <kba@cpan.org>

A big hug to mst for namespacing help.

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2011 by Ran Eilam

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.10.1 or,
at your option, any later version of Perl 5 you may have available.

=cut

package Games::TMX::Parser;

use Moose;
use File::Spec;
use XML::Twig;

has [qw(map_dir map_file)] => (is => 'ro', isa => 'Str', required => 1);

has map => (is => 'ro', lazy_build => 1, handles => [qw(get_layer)]);

has twig => (is => 'ro', lazy_build => 1);

sub _build_twig {
    my $self = shift;
    my $twig = XML::Twig->new;
    $twig->parsefile
        ( File::Spec->catfile($self->map_dir, $self->map_file) );
    return $twig;
}

sub _build_map {
    my $self = shift;
    return Games::TMX::Parser::Map->new(el => $self->twig->root, parser => $self);
}

# ------------------------------------------------------------------------------

package Games::TMX::Parser::MapElement;

use Moose;

has parser => ( is => 'ro' );

has el => (is => 'rw', required => 1, handles => [qw(
    att att_exists first_child children print replace replace_with
)]);

# ------------------------------------------------------------------------------

package Games::TMX::Parser::Map;

use Moose;

extends 'Games::TMX::Parser::MapElement';

has [qw(layers objectgroups tilesets width height tile_width tile_height tiles_by_id)] =>
    (is => 'ro', lazy_build => 1);

sub _build_layers {
    my $self = shift;
    return {map { $_->att('name') =>
        Games::TMX::Parser::Layer->new(el => $_, map => $self)
    } $self->children('layer') };
}

sub _build_objectgroups {
    my $self = shift;
    return {map { $_->att('name') =>
        Games::TMX::Parser::ObjectGroup->new(el => $_, map => $self)
    } $self->children('objectgroup') };
}

sub _build_tiles_by_id {
    my $self  = shift;
    my @tiles = map { @{$_->tiles} } @{ $self->tilesets };
    return {map { $_->id => $_ } @tiles};
}

sub _build_tilesets {
    my $self = shift;
    return [map {
        Games::TMX::Parser::TileSet->new(el => $_, map => $self)
    } $self->children('tileset') ];
}

sub _build_width       { shift->att('width') }
sub _build_height      { shift->att('height') }
sub _build_tile_width  { shift->att('tilewidth') }
sub _build_tile_height { shift->att('tileheight') }

sub get_layer { shift->layers->{pop()} }
sub get_objectgroup { shift->objectgroups->{pop()} }
sub get_tile  { shift->tiles_by_id->{pop()} }

# ------------------------------------------------------------------------------

package Games::TMX::Parser::TileSet;

use Moose;
use List::MoreUtils qw(natatime);
use Data::Dumper;

extends 'Games::TMX::Parser::MapElement';

has [qw(first_gid image tiles width height tile_width tile_height tile_count map)] =>
    (is => 'ro', lazy_build => 1);

sub _build_tiles {
    my $self = shift;
    my $first_gid = $self->first_gid;
    
    if (my $tsx_file = $self->att("source")) {
#        warn "External tilesets (TSX) not implemented yet.";
        my $tsx_twig = XML::Twig->new;
        $tsx_twig->parsefile( File::Spec->catfile($self->map->parser->map_dir, $tsx_file) );
        # TODO
        # warn Dumper $self->el;
#        $self->el->print;
#        $tsx_twig->children('tileset')->print;
        $self->el( $tsx_twig->children('tileset') );
#        $self->el->print;
        # warn Dumper $self->el;
        # return [];
    }

    # index tiles with properties
    my $prop_tiles = {map {
        my $el = $_;
        my $id = $first_gid + $el->att('id');
        my $properties = {map {
           $_->att('name'), $_->att('value') 
        } $el->first_child('properties')->children};
        my $tile = Games::TMX::Parser::Tile->new
            (id => $id, properties => $properties, tileset => $self);
        ($id => $tile);
    } $self->children('tile')};

    # create a tile object for each tile in the tileset
    # unless it is a tile with properties
    my @tiles;
    my $it = natatime $self->width, 1..$self->tile_count;
    while (my @ids = $it->()) {
        for my $id (@ids) {
            my $gid = $first_gid + $id;
            my $tile = $prop_tiles->{$gid} || 
                Games::TMX::Parser::Tile->new(id => $gid, tileset => $self);
            push @tiles, $tile;
        }
    }
    return [@tiles];
}

sub _build_tile_count {
    my $self = shift;
    return ($self->width      * $self->height     ) /
           ($self->tile_width * $self->tile_height);
}

sub _build_first_gid   { shift->att('firstgid') }
sub _build_tile_width  { shift->att('tilewidth') }
sub _build_tile_height { shift->att('tileheight') }
sub _build_image       { shift->first_child('image')->att('source') }
sub _build_width       { shift->first_child('image')->att('width') }
sub _build_height      { shift->first_child('image')->att('height') }

# ------------------------------------------------------------------------------

package Games::TMX::Parser::Tile;

use Moose;

has id      => (is => 'ro', isa => 'Int', required => 1);
has tileset => (is => 'ro', weak_ref => 1, required => 1);

has properties => (is => 'ro', isa => 'HashRef', default => sub { {} });

sub get_prop {
    my ($self, $name) = @_;
    return $self->properties->{$name};
}

# ------------------------------------------------------------------------------

package Games::TMX::Parser::Layer;

use Moose;
use List::MoreUtils qw(natatime);

has map => (is => 'ro', required => 1, weak_ref => 1, handles => [qw(
    width height tile_width tile_height get_tile
)]);

has rows => (is => 'ro', lazy_build => 1);

extends 'Games::TMX::Parser::MapElement';

sub _build_rows {
    my $self = shift;
    my @rows;
    my $it = natatime $self->width, $self->first_child->children('tile');
    my $y = 0;
    while (my @row = $it->()) {
        my $x = 0;
        push @rows, [map {
            my $el = $_;
            my $id = $el->att('gid');
            my $tile;
            $tile = $self->get_tile($id) if $id;
            Games::TMX::Parser::Cell->new
                (x => $x++, y => $y, tile => $tile, layer => $self)
        } @row];
        $y++;
    }
    return [@rows];
}

sub find_cells_with_property {
    my ($self, $prop) = @_;
    return grep {
        my $cell = $_;
        my $tile = $cell->tile;
        $tile && exists $tile->properties->{$prop};
    } $self->all_cells;
}

sub get_cell {
    my ($self, $col, $row) = @_;
    return $self->rows->[$row]->[$col];
}

sub all_cells { return map { @$_ } @{ shift->rows } }

# ------------------------------------------------------------------------------

package Games::TMX::Parser::Cell;

use Moose;

has [qw(x y)] => (is => 'ro', isa => 'Int', required => 1);

has tile => (is => 'ro');

has layer => (is => 'ro', required => 1, weak_ref => 1, handles => [qw(
    get_cell width height
)]);

my %Dirs      = map { $_ => 1 } qw(below left right above);
my %Anti_Dirs = (below => 'above', left => 'right', right => 'left', above => 'below');

sub left  { shift->neighbor(-1, 0) }
sub right { shift->neighbor( 1, 0) }
sub above { shift->neighbor( 0,-1) }
sub below { shift->neighbor( 0, 1) }

sub xy { ($_[0]->x, $_[0]->y) }

sub neighbor {
    my ($self, $dx, $dy) = @_;
    my $x = $self->x + $dx;
    my $y = $self->y + $dy;
    return undef if $x < 0            || $y < 0;
    return undef if $x > $self->width || $y > $self->height;
    return $self->get_cell($x, $y);
}

sub seek_next_cell {
    my ($self, $dir) = @_;
    my %dirs = %Dirs;
    delete $dirs{$Anti_Dirs{$dir}} if $dir;
    for my $d (keys %dirs) {
        my $c = $self->$d;
        return [$c, $d] if $c && $c->tile;
    }
    return undef;
}

1;

# ------------------------------------------------------------------------------

package Games::TMX::Parser::ObjectGroup;

use Moose;
use List::MoreUtils qw(natatime);

extends 'Games::TMX::Parser::MapElement';

has map => (is => 'ro', required => 1, weak_ref => 1, handles => [qw(
    width height tile_width tile_height get_tile
)]);

has objects => (
    is        => 'rw',
    isa       => 'ArrayRef[Games::TMX::Parser::Object]',
    traits    => ['Array'],
    handles => {
        add_object => 'push',
        list_objects => 'elements',
        grep_objects => 'grep',
        map_objects => 'map',
    },
    lazy_build => 1,
);

sub list_object_names {
    my $self = shift;
    my @names = $self->map_objects(sub{$_->name});
    return wantarray ? @names : \@names;
}

sub get_objects_by_name {
    my $self = shift;
    my $name = shift;
    my @objects = $self->grep_objects(sub{$_->name && $_->name eq $name});
    return wantarray ? @objects : \@objects;
}

sub _build_objects {
    my $self = shift;
    my @objects;
    my ($y, $x, $w, $h);
    for my $el ($self->children('object') ) {
        my $object_type;

        # determine object type
        if ($el->att('width')) {
            $object_type = 'Rectangle';
        }
        elsif ($el->att('gid')) {
            $object_type = 'Tile';
        }
        elsif (scalar $el->children('polygon')) {
            $object_type = 'Polygon';
        }
        elsif (scalar $el->children('polyline')) {
            $object_type = 'Polyline';
        }
        unless ($object_type && $object_type =~ m/^(?: Rectangle | Tile | Polyline | Polygon )$/x) {
            warn "This object type [$object_type] isn't implemented yet.";
            next;
        };
        my $obj_pkg = "Games::TMX::Parser::Object::$object_type";
        my %new_args = (
            el          => $el,
            x           => $el->att('x'),
            y           => $el->att('y'),
            objectgroup => $self,
        );
        $new_args{name} = $el->att('name') if $el->att('name');
        push @objects, $obj_pkg->new( %new_args );
    }
    return \@objects;
}

sub objects_for_position_yx {
    my $self = shift;
    my ($y, $x) = @_;
    my @objects;
    for my $obj ($self->list_objects) {
        if ($obj->grep_positions_yx(sub { $_->[0] == $y && $_->[1] == $x })) {
            push @objects, $obj;
            next;
        };
    }
    return \@objects;
}

1;

# ------------------------------------------------------------------------------

package Games::TMX::Parser::Object;

use Moose;

extends 'Games::TMX::Parser::MapElement';

has [qw(x y)] => (is => 'ro', isa => 'Int', required => 1);

has name => (is => 'rw', isa => 'Str');

has positions_yx => (
    is         => 'ro',
    isa        => 'ArrayRef[ArrayRef[Int]]',
    lazy_build => 1,
    traits     => ['Array'],
    handles => {
        'grep_positions_yx' => 'grep',
    },
);

has objectgroup => (is => 'ro', isa => 'Games::TMX::Parser::ObjectGroup', required => 1);

sub xy { ($_[0]->x, $_[0]->y) }

sub dump_object {
    my $self = shift;
    my @dump;
    for my $y (0..$self->objectgroup->height) {
        for my $x (0..$self->objectgroup->width) {
            $dump[$y]->[$x] = ".";
        }
    }
    for (@{$self->positions_yx}) {
        $dump[$_->[0]]->[$_->[1]]  = '#';
    }
    my $out = "";
    map {$out .= join("", @$_) . "\n"} @dump;
    return $out;
}

1;

# ------------------------------------------------------------------------------

package Games::TMX::Parser::Object::Rectangle;

use Moose;

extends 'Games::TMX::Parser::Object';

has [qw(width height)] => (is => 'ro', isa => 'Int', required => 1);

around BUILDARGS => sub {
    my $orig  = shift;
    my $class = shift;
    my %args = @_;
    $args{width}  = $args{el}->att('width');
    $args{height} = $args{el}->att('height');
    return $class->$orig(%args);
};

sub _build_positions_yx {
    my $self = shift;
    my @positions;
    my $tile_height = $self->objectgroup->tile_height;
    my $tile_width = $self->objectgroup->tile_width;
    my $y_tile = ($self->y / $tile_height);
    my $x_tile = ($self->x / $tile_width);
    my $y_tile_max = ($y_tile + $self->width / $tile_height - 1);
    my $x_tile_max = ($x_tile + $self->height / $tile_width - 1);
    for (my $y = $y_tile; $y <= $y_tile_max; $y++) {
        for (my $x = $x_tile; $x <= $x_tile_max; $x++) {
            push @positions, [ $y, $x ];
        }
    }
    return \@positions;
}

# ------------------------------------------------------------------------------

package Games::TMX::Parser::Object::Tile;

use Moose;

extends 'Games::TMX::Parser::Object';

has tile => (is => 'ro', required => 1);

around BUILDARGS => sub {
    my $orig  = shift;
    my $class = shift;
    my %args = @_;
    $args{tile}  = $args{objectgroup}->map->get_tile($args{el}->att('gid'));
    return $class->$orig(%args);
};

sub _build_positions_yx {
    my $self = shift;
    return [[$self->y/$self->objectgroup->tile_height - 1, $self->x / $self->objectgroup->tile_width]];
}

1;

# ------------------------------------------------------------------------------

package Games::TMX::Parser::Object::Polyline;

use Moose;
use Algorithm::Line::Bresenham;

extends 'Games::TMX::Parser::Object';

has points => (is => 'ro', isa => 'ArrayRef[ArrayRef[Int]]', required => 1 );

sub el_name {'polyline'};

around BUILDARGS => sub {
    my $orig  = shift;
    my $class = shift;
    my %args = @_;
    my $i = 0;
    my @points_raw = map {[reverse split /,/, "$_"]} split /\s+/, $args{el}->first_child($class->el_name)->att('points');
    my @points = map {[ $_->[0] + $args{y} , $_->[1] + $args{x}]} @points_raw;
    $args{points} = \@points;
    return $class->$orig(%args);
};


sub _build_positions_yx {
    my $self = shift;
    my %positions_hash;

    my $tile_height = $self->objectgroup->tile_height;
    my $tile_width = $self->objectgroup->tile_width;

    # draw polyline
    my @points = map { [ $_->[0] / $tile_height, $_->[1] / $tile_width ] } @{ $self->points };
    my $start_point = shift @points;
    for my $end_point (@points) {
        my @positions_line = Algorithm::Line::Bresenham::line(@$start_point, @$end_point);
        # hack to remove duplicates
        map {$positions_hash{join ",", @$_} = $_} @positions_line;
        $start_point = $end_point;
    }

    # return [sort {$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1]} values %positions_hash];
    return [values %positions_hash];
}

1;

# ------------------------------------------------------------------------------

package Games::TMX::Parser::Object::Polygon;

use Moose;

extends 'Games::TMX::Parser::Object::Polyline';

sub el_name {'polygon'};

sub BUILD {
    my $self = shift;

    # close the polygon
    push @{ $self->points }, $self->points->[0];
}

around _build_positions_yx => sub {
    my $orig  = shift;
    my $self = shift;
    my @outline_points = @{$self->$orig()};
    my @fill_points;

    # TODO this breaks for more complex polygons, probably because
    # of the fill_flag thingy. Have to investigate
    # do scan line fill 
    my $max_y = 0;
    my $max_x = 0;
    map { 
        $max_y = $_->[0] > $max_y ? $_->[0] : $max_y;
        $max_x = $_->[1] > $max_x ? $_->[1] : $max_x 
    } @{ $self->points };

    my $y_end = $max_y / $self->objectgroup->tile_height;
    my $y_start = $self->y / $self->objectgroup->tile_height;
    my $x_end = $max_x / $self->objectgroup->tile_width;
    my $x_start = $self->x / $self->objectgroup->tile_width;

    for my $y (reverse($y_start .. $y_end)) {
        my $fill_flag = 0;
        my $fill_flag_before = 0;
        for my $x ($x_start .. $x_end) {
            if ( 
                grep( { $_->[0] == $y && $_->[1] == $x } @outline_points )
                && ! $fill_flag_before
            ) {
                $fill_flag = not $fill_flag;
            }
            if ($fill_flag) {
                push @fill_points, [$y, $x];
            }
            $fill_flag_before = $fill_flag;
        }
    }

    return [@outline_points, @fill_points];
};

1;
